<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" type="image/png" href="/images/cabin.png"><link href="/styles/main.css" rel="stylesheet"><title>World Wide Web Home of Matthew Phillips</title></head><body><ul class="nav group"><li class="icon-menu menu"></li><li class="nav-link red active"><a href="/" class="name">WWW Home</a></li><li class="nav-link blue"><a href="/about.html">about</a></li><li class="nav-link orange"><a href="/projects.html">projects</a></li><li class="nav-link green"><a href="/archives.html">archives</a></li></ul><div class="content"><div class="post"><div class="post-head group"><a href="/posts/markdown-enable-your-blog-comments-with-web-components.html"><h1 class="post-title">Markdown Enable Your Blog Comments with Web Components</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-02-01T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p>If you&#39;re like me and are excited about getting started using web components today, you might find yourself struggling coming up with practical uses that aren&#39;t the typical carousel, calendar, or <a href="http://matthewphillips.info/posts/building-an-accordion-with-can-component.html">accordion</a> widgets that we&#39;ve all written a hundred times in plain JavaScript.</p>
<p>In this article I&#39;ll walk you through the process of:</p>
<ul>
<li><p>Finding a practical use for web components.</p>
</li>
<li><p>Developing your first iteration.</p>
</li>
<li><p>Refining, deciding when components are needed and when they are just extra fluff.</p>
</li>
</ul>
<p>All of my examples will use <a href="http://canjs.com/guides/Components.html">can.Component</a> because it&#39;s available today, is stable, and has really good browser support, but are still applicable no matter what your web component framework of choice is.</p>
<h1><a name="from-concept-to-code" class="anchor" href="#from-concept-to-code"><span class="header-link"></span></a>From Concept to Code</h1>
<p>If all you&#39;re interested in is learning you can pick just about any API on the web and turn it into a web component. Or pick your favorite JavaScript library and wrap a component around it. Web components are primed to be the new jQuery plugin.</p>
<h2><a name="markdown" class="anchor" href="#markdown"><span class="header-link"></span></a>Markdown</h2>
<p>If you&#39;re a programmer you probably use markdown (or another markup generator) quite often. I&#39;m writing this post in markdown right now. The only downside is I have a Grunt task running in the background that is rerendering the html every time I save the file. What if you could write markdown and have it generate all in the browser? You want to write something like:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;markdown&gt;</span>
# Hello world!

* Oh my, **lists**
<span class="nt">&lt;/markdown&gt;</span>
</pre></div>
</code></pre>
<p>And let a library do the heavy lifting. Luckily there is a <a href="https://github.com/coreyti/showdown">Showdown</a>, a JavaScript library for turning markdown into HTML. It&#39;s pretty fantastic. So let&#39;s make a component.</p>
<p>Since Showdown does most of the heavy lifting all we need is a nice wrapper that will allow us to write Markdown inside of a tag and have it render the HTML automatically. Using can.Component we can do that easily, here&#39;s a demo:</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/TBFp6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>The code should speak for itself. The <code>x-markdown</code> component (all web components should be namespaced, we use <code>x-</code> in this example) generates the HTML after it is inserted into the page. We simply listen for the <code>inserted</code> event and set the <code>&lt;content/&gt;</code> provided by the user to the <code>markdown</code> property on the component&#39;s Scope.</p>
<p>The powerful part of this example is the <code>can.compute</code>. Computes are a type of object that can listen to changes of other objects and automatically recompute themselves. If you&#39;ve used <a href="http://knockoutjs.com/documentation/observables.html">ko.observable</a> or Ember <a href="http://emberjs.com/guides/object-model/computed-properties/">computed properties</a> the idea is much the same, but can.computes are a bit more powerful (we&#39;ll get to that later).</p>
<p>The compute simple takes the value of the <code>markdown</code> property (which is set in the <code>inserted</code> event) and uses Showdown to generate the html that will be displayed.</p>
<h1><a name="using-with-blog-comments" class="anchor" href="#using-with-blog-comments"><span class="header-link"></span></a>Using with Blog Comments</h1>
<p>While cool, this example isn&#39;t that practical. In reality you&#39;ll rarely have a scenario where you need to write HTML inside of a web browser, otherwise using a static site generator is probably what you&#39;ll be using.</p>
<p>One place where you would want to generate the HTML on the fly is for blog comments. If your blog is developer-focused it makes sense to allow the reader to write comments in markdown, and have a live preview of what it will look like. So let&#39;s refactor <code>&lt;x-markdown&gt;</code> to be our live preview.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">can</span><span class="p">.</span><span class="nx">Component</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">tag</span><span class="o">:</span> <span class="s1">&#39;x-markdown&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;div&gt;{{{html}}}&lt;/div&gt;&#39;</span><span class="p">,</span>
  <span class="nx">scope</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">html</span><span class="o">:</span> <span class="nx">can</span><span class="p">.</span><span class="nx">compute</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">markdown</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;markdown&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">converter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">html</span> <span class="o">=</span> <span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span><span class="p">(</span><span class="nx">markdown</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">html</span><span class="p">;</span>
    <span class="p">}),</span>
    <span class="nx">markdown</span><span class="o">:</span> <span class="s1">&#39;&#39;</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>This new version of <code>&lt;x-markdown&gt;</code> is much more succinct because we&#39;ve eliminated the <code>&lt;content/&gt;</code> portion by getting the raw markdown from a textarea. can.Component allows you to pass data (included complex objects) through an element&#39;s attribute tags. We&#39;ll use it like such: <code>&lt;x-markdown markdown=&quot;value&quot;&gt;&lt;/x-markdown&gt;</code> so that the <code>html</code> compute will be live-bound to the <code>value</code> object that we pass in.</p>
<p>Next we need to create a live-bound textarea we&#39;ll call <code>&lt;x-textarea&gt;</code>. The idea that both x-markdown and x-textarea will be live-bound to the same compute object, and any time you type into the textarea the markdown will automatically be rerendered in the preview window. Demo time:</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/TBFp6/1/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>Try out the fiddle (Click on the <strong>Result</strong> link) and see for yourself how the preview updates as you type. The secret sauce here is that we are using <code>can-value</code> to bind the textarea&#39;s <code>value</code> to our scope property also called <code>value</code>. can-value works on the element&#39;s <code>change</code> event, which for most types of forms is fine, but in our case we need the preview to update as you type, so we&#39;ve added a <code>keyup</code> event that simply triggers the textarea&#39;s change event as the user types. Simple!</p>
<h1><a name="when-not-to-web-component" class="anchor" href="#when-not-to-web-component"><span class="header-link"></span></a>When not to Web Component</h1>
<p>Awesome, we&#39;ve built a live-bound markdown enabled comment system. In less than 30 lines of code. However you might notice that the <code>&lt;x-textarea&gt;</code> isn&#39;t really doing much at all. It simply turns a normal textarea into a live-bound one.</p>
<p>However in reality textareas <em>really are</em> live-bound, they use the normal DOM events to update their values. So all we are using the <code>&lt;x-textarea&gt;</code> for in practice is to turn the DOM events into can events. Luckily <a href="http://canjs.com/docs/can.compute.html">can.compute</a> already has a way of doing this, so we don&#39;t need the <code>x-textarea</code> at all.</p>
<p>can.compute can take a set of arguments that includes an element, the property to bind to, and an event to bind to. We&#39;ll use it like:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="kd">var</span> <span class="nx">markdown</span> <span class="o">=</span> <span class="nx">can</span><span class="p">.</span><span class="nx">compute</span><span class="p">(</span><span class="nx">textarea</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;keyup&#39;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>This allows us to move our textarea outside of the script tag (since we&#39;re getting rid of the component) but still have a live-bound value between the textarea and our <code>x-markdown</code> preview. See the demo below.</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/TBFp6/2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>Hopefully I&#39;ve demonstrated the process of coming up with an idea for a component (essentially an encapsulated piece of HTML with JavaScript interactivity) and refining it until you are left with only the bits of code that you need. We&#39;ve created a Markdown-enabled blog commenting system is only 18 lines of code. Let it be inspiration for your next component. Can you do better, how about an MDN reference widget?</p>
</div></div><div class="post"><div class="post-head group"><a href="/posts/building-an-accordion-with-can-component.html"><h1 class="post-title">Building an accordion with can.Component</h1></a><h2 class="post-date">Published&nbsp<abbr title="2013-12-02T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p>I learn best by doing, so in an effort to learn more about <a href="http://canjs.com/guides/Components.html">can.Component</a> I&#39;ve been creating common types of components using the new framework. An <strong>accordion</strong> is one such example and I wanted to write about my experience creating the component. Note that this article doesn&#39;t constitute a best practice, I&#39;ve only been using can.Component for a few weeks now. Nor is the goal here for the least amount of code (My first couple of iterations used less code actually), rather I wanted to write the component as DRY as possible.</p>
<p>I&#39;ve long been a fan of the <a href="http://www.w3.org/TR/components-intro/">Web Components</a> and was excited at the idea that <a href="http://canjs.com/index.html">can</a> could make it possible to write components today. Components are much different than traditional MVC-style programming, in that much more of your code is spent expressing what a component is rather than listening for DOM events and reacting. To that purpose, when I set out to create an accordion control I started with what I wanted it to look like in the end.</p>
<p>An accordion is made up of a list of elements, each with a header and content, that when the header is clicked the content collapses and only the header is shown. So in the end, our html should look something like:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;accordion&gt;</span>
  <span class="nt">&lt;collapsible&gt;</span>...<span class="nt">&lt;/collapsible&gt;</span>
  <span class="nt">&lt;collapsible&gt;</span>...<span class="nt">&lt;/collapsible&gt;</span>
  <span class="nt">&lt;collapsible&gt;</span>...<span class="nt">&lt;/collapsible&gt;</span>
<span class="nt">&lt;/accordion&gt;</span>
</pre></div>
</code></pre>
<p>Note that we actually have 2 components here. It&#39;s important that the <code>collapsible</code> component operate independently of being hosted inside of an <code>accordion</code>. This leads to DRYer code, a <code>collapsible</code> component is something that can be useful in a lot of places.</p>
<h2><a name="collapsible" class="anchor" href="#collapsible"><span class="header-link"></span></a>Collapsible</h2>
<p>So first to build our <code>collapsible</code> component. Like I said before, a <code>collapsible</code> has a header containing a title, and it has a content section. It should look something like:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;collapsible</span> <span class="na">class=</span><span class="s">&quot;open&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;header&gt;</span>
    <span class="nt">&lt;h1&gt;</span>This is a title<span class="nt">&lt;/h1&gt;</span>
  <span class="nt">&lt;/header&gt;</span>
  <span class="nt">&lt;article&gt;</span>This is content.<span class="nt">&lt;/article&gt;</span>
<span class="nt">&lt;/collapsible&gt;</span>
</pre></div>
</code></pre>
<p>Note that the collapsible contains a class called <code>open</code>. This will be used with CSS to control the <code>article</code>&#39;s height. If the collapsible is not open we&#39;ll hide it by setting its height to <code>0px</code> and overflow to <code>none</code>. Now to the code for this component:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">can</span><span class="p">.</span><span class="nx">Component</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">tag</span><span class="o">:</span> <span class="s1">&#39;collapsible&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;header can-click=&quot;toggle&quot;&gt;&lt;h1&gt;{{item.title}}&lt;/h1&gt;&lt;/header&gt;&#39;</span> <span class="o">+</span>
    <span class="s1">&#39;&lt;article&gt;{{item.content}}&lt;/article&gt;&#39;</span><span class="p">,</span>
  <span class="nx">scope</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">item</span><span class="o">:</span> <span class="k">new</span> <span class="nx">can</span><span class="p">.</span><span class="nx">Map</span><span class="p">({}),</span>
    <span class="nx">toggle</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;item.open&#39;</span><span class="p">,</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;item.open&#39;</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
    <span class="s1">&#39;{item} open&#39;</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">ev</span><span class="p">,</span> <span class="nx">newVal</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">element</span><span class="p">[</span><span class="nx">newVal</span> <span class="o">?</span> <span class="s1">&#39;addClass&#39;</span> <span class="o">:</span> <span class="s1">&#39;removeClass&#39;</span><span class="p">](</span><span class="s1">&#39;open&#39;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>It&#39;s pretty straight forward. The <code>can-click=&quot;toggle&quot;</code> attribute tells can that when the header is clicked, call the <code>toggle</code> function, which is part of the component&#39;s scope. The <code>toggle</code> function simple toggle the <code>item</code>&#39;s <code>open</code> flag. Then we have an event that listens for the changes to <code>open</code> and sets the element&#39;s class appropriately. Note that I could have placed the <code>open</code> class as part of the <code>&lt;article&gt;</code> element. The advantage to doing it that way is that it could have been included in the template which would have avoided the entire events section of the code. Ultimately I decided that it was more <em>correct</em> to have the <code>collapsible</code> itself be either open or not. Either approach is valid. The CSS is straight forward, but if you&#39;re a better designer than I you might use transforms or transitions.</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="nt">collapsible</span> <span class="nt">article</span> <span class="p">{</span>
  <span class="k">overflow</span><span class="o">:</span> <span class="k">hidden</span><span class="p">;</span>
  <span class="k">height</span><span class="p">;</span> <span class="m">0px</span><span class="p">;</span>
<span class="p">}</span>

<span class="nt">collapsible</span><span class="nc">.open</span> <span class="nt">article</span> <span class="p">{</span>
  <span class="k">height</span><span class="o">:</span> <span class="k">auto</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</code></pre>
<p>You can try this on your own, using this simple component you have a collapsible header/content panel.</p>
<h2><a name="accordion" class="anchor" href="#accordion"><span class="header-link"></span></a>Accordion</h2>
<p>An accordion simple wraps a number of <code>collapsible</code>s and has 1 extra feature: it ensures that only 1 collapsible is open at a time. So in order to create my accordion I really only need a couple of things:</p>
<ol>
<li>A way to listen for when a collapsible&#39;s <code>open</code> property changes.</li>
<li>A way to determine which items need to be set to closed.</li>
</ol>
<p>Below is the code that creates our accordion, take a look first and then I&#39;ll step you through what is happening.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">can</span><span class="p">.</span><span class="nx">Component</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">tag</span><span class="o">:</span> <span class="s1">&#39;accordion&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;{{#each items}}&lt;collapsible item=&quot;items.{{@index}}&quot;&gt;&#39;</span> <span class="o">+</span>
    <span class="s1">&#39;&lt;/collapsible&gt;{{/each}}&#39;</span><span class="p">,</span>
  <span class="nx">scope</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">items</span><span class="o">:</span> <span class="k">new</span> <span class="nx">can</span><span class="p">.</span><span class="nx">List</span><span class="p">([]).</span>
    <span class="nx">selected</span><span class="o">:</span> <span class="s1">&#39;@&#39;</span><span class="p">,</span>
    <span class="nx">select</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">index</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;items&#39;</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">isOpen</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">===</span> <span class="nx">index</span><span class="p">;</span>
        <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="nx">isOpen</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
    <span class="s1">&#39;inserted&#39;</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
      <span class="kd">var</span> <span class="nx">selected</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">scope</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;selected&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">scope</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="nx">selected</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="s1">&#39;{items} change&#39;</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">ev</span><span class="p">,</span> <span class="nx">what</span><span class="p">,</span> <span class="nx">how</span><span class="p">,</span> <span class="nx">newVal</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="o">~</span><span class="nx">what</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;open&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">newVal</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">which</span> <span class="o">=</span> <span class="o">+</span><span class="nx">what</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">what</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">));</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">scope</span><span class="p">.</span><span class="nx">select</span><span class="p">(</span><span class="nx">which</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>The first thing you&#39;re likely to notice is that we&#39;re attaching this to the collapsible: <code>item=&quot;items.{{@index}}&quot;</code>. We are doing this because the way you pass data to a child component is through its attributes. The attribute&#39;s name is the name of the property on the component&#39;s scope that we want to set, in this case <code>item</code>. The attribute value is the name of the parent scope&#39;s property that we want to pass in, in this case <code>item.0</code> (or <code>item.1</code>, etc. <code>{{@index}}</code> gets the index inside of our each loop).</p>
<p>Since the <code>collapsible</code> controls its own <code>open</code> state we only need to observe changes that happen to our children items. This is what is happening in the <code>{items} change</code> event. Any time something changes to one of our items we check to see if it is an open event, and if so we run the scope&#39;s <code>select</code> method which takes the index of the item that is selected and marks all others as closed (by changing their <code>close</code> property, which automatically prompts an event in the <code>collapsible</code> component which is what actually removes the class.</p>
<p>And that&#39;s pretty much all there is to an accordion. One other thing you might be unaware of is why the scope has a <code>selected</code> property with a value of <code>@</code>. This means that we want to use the value of the attribute rather than an object it refers to. We use this so that you can pass in the default collapsible to open like so: <code>&lt;accordion selected=&quot;2&quot;&gt;&lt;/accordion&gt;</code> means that the <code>collapsible</code> with an index of 2 will be open and all others closed.</p>
<h2><a name="summary" class="anchor" href="#summary"><span class="header-link"></span></a>Summary</h2>
<p>As you can see, creating reusable components with can.Component is fairly straight forward. It&#39;s just a matter of rethinking how you design a component, to be more declarative. I&#39;m hopeful that designing this way will make it more natural to create smaller, more modular components. Your application itself should be merely a declaration of componenents and bindings of data between them.</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/a6r3c/6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</div></div><div class="pagination group"><a href="/page/1/" class="older">&#8592; Older</a></div></div><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.1.0/jquery.timeago.min.js" type="text/javascript"></script><script src="/scripts/main.js" type="text/javascript"></script></body></html>