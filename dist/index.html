<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" type="image/png" href="/images/cabin.png"><link href="/styles/main.css" rel="stylesheet"><title>World Wide Web Home of Matthew Phillips</title></head><body><ul class="nav group"><li class="icon-menu menu"></li><li class="nav-link red active"><a href="/" class="name">WWW Home</a></li><li class="nav-link blue"><a href="/about.html">about</a></li><li class="nav-link orange"><a href="/projects.html">projects</a></li><li class="nav-link green"><a href="/archives.html">archives</a></li></ul><div class="content"><div class="post"><div class="post-head group"><a href="/posts/fun-with-shadow-dom.html"><h1 class="post-title">Fun with Shadow DOM</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-04-02T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p><strong>Update</strong>: To do this demo you first need to enable experimental web platform features <a href="chrome://flags/#enable-experimental-web-platform-features">in chrome://flags</a>.</p>
<p>Now that Chrome has shipped Shadow DOM we can start experimenting with what possibilities are going to open up to developers. Consider this a beginner/intermediate post about Shadow DOM. I assume you already know Shadow DOM is a way to &quot;hide&quot; an element&#39;s structure while opening up insertion points to its inner content.</p>
<p>With that in mind, this is a simple exercise in seeing the weirdness that is Shadow DOM. So open up a text editor and create an HTML file with these contents:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;title&gt;</span>Fun with Shadow<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;container&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;template</span> <span class="na">id=</span><span class="s">&quot;tmpl&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;div</span> <span class="p">{</span> <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span> <span class="p">}</span><span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;div&gt;</span>Hello <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;name&quot;</span><span class="nt">&gt;</span>Matthew<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;template</span> <span class="na">id=</span><span class="s">&quot;tmpl2&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div&gt;</span>Welcome to the internet<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;shadow&gt;&lt;/shadow&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</code></pre>
<p>From here on the rest of the tutorial is done from Chrome&#39;s DevTools. So open your brower and navigate to the page you just created and open the DevTools. This is a simple page with a container div and a couple of templates.</p>
<p>You should see nothing on your page at this point, but we&#39;ll change that. The element <code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</code> is the root element we&#39;re going to play around with so go ahead and get a reference to it.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#container&#39;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Next we&#39;re going to create this div&#39;s <a href="http://www.w3.org/TR/shadow-dom/#dfn-shadow-root">shadow root</a>. The shadow root is the place where you can append stuff to the div and not have to worry about the page&#39;s styling interfering (among other advantages).</p>
<p>Before we create the shadow root, type this into the console and hit enter:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span>
</pre></div>
</code></pre>
<p>It should return <code>null</code>, as the div doesn&#39;t have a shadow root yet. So let&#39;s go ahead and change that. Create the shadow root and keep a reference for later:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root1</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>Should return (in the console):</p>
<pre><code><div class="highlight"><pre><span class="err">#</span><span class="nx">shadow</span><span class="o">-</span><span class="nx">root</span>
</pre></div>
</code></pre>
<p>This also updates <code>c.shadowRoot</code>. Test it by doing:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root1</span> <span class="o">===</span> <span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span>
</pre></div>
</code></pre>
<p>And you&#39;ll get <code>true</code>. Awesome. Now that you have a shadow root you&#39;ll want to add stuff to it. This works like any other element. You can use <code>innerHTML</code>, <code>appendChild</code>, <code>insertBefore</code>, etc. to add content to the shadow. Let&#39;s use our first template to attach some content:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root1</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#tmpl&#39;</span><span class="p">).</span><span class="nx">content</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The immediate effect you&#39;ll see is the words &quot;Hello Matthew&quot; in red on the page. This is because the template contains a <code>&lt;style&gt;</code> tag that styles the content within the template.</p>
<p>You&#39;ll also notice that we <em>didn&#39;t</em> append the template, we appended the template&#39;s <code>content</code> property. This is a read-only property containing a document fragment of the template&#39;s content.</p>
<p>If you navigate to the DevTools&#39; <strong>Elements</strong> tab and expand the <code>#container</code> div you&#39;ll see... nothing at all. This is because shadow root is hidden by default. You can change this by going into Settings -&gt; Elements and selecting <em>Show Shadow DOM</em>. Now go back to <strong>Elements</strong> and you&#39;ll see a <code>#shadow-root</code> nested under your div. Yay!</p>
<h2><a name="deeper-down-the-rabbit-hole" class="anchor" href="#deeper-down-the-rabbit-hole"><span class="header-link"></span></a>Deeper down the rabbit hole</h2>
<p>We could stop here and you&#39;d have a good idea of what the Shadow DOM allows you to do, and how to use an element&#39;s shadow root. But we&#39;re going to take it one step further. When we created the shadow root you might have asked yourself why there is a method <code>createShadowRoot</code> in the first place. Does it mean you can have multiple shadow root&#39;s in an element? It does!</p>
<p>So let&#39;s go ahead and create a second shadow root to further our experimentation:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root2</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>This will return a new shadow root. But what you might also notice is that the words &quot;Hello Matthew&quot; disappeared from the page. What&#39;s going on? First use the <strong>Elements</strong> tab and expand your <code>#container</code> div and there should now be two shadow roots. The first is <code>root1</code> and its contents are still there. That&#39;s good, but why can&#39;t we see it?</p>
<p>The reason is that the browser only renders the <em>last</em> shadow tree. The others are still there, you just can&#39;t see them. In your console do this:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span> <span class="o">==</span> <span class="nx">root1</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span> <span class="o">==</span> <span class="nx">root2</span>
</pre></div>
</code></pre>
<p>As you can see, the div&#39;s new shadowRoot is now <code>root2</code>. You might be asking how this is useful... I&#39;ll get to an explanation but it might be better to show you. Go ahead and attach that other template to the new root:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root2</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#tmpl2&#39;</span><span class="p">).</span><span class="nx">content</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Ah! The first shadow&#39;s content is back. This is because <code>#tmpl2</code> has an insertion point with <code>&lt;shadow&gt;&lt;/shadow&gt;</code>. This says &quot;insert the previous shadow here&quot;, more or less. You may also notice that the second template&#39;s div is not in red. This is because the <code>&lt;style&gt;</code> tag in the first template is scoped to only content within that template. This is the beauty of templates.</p>
<p>Back to the question, how is multiple shadow trees useful anyways? A big part of web components is going to be extending existing components. Shadow DOM provides an excellent way to do that. Let&#39;s say I created <code>&lt;super-calendar&gt;</code> and it was awesome... but ugly. You might want to come around and create <code>&lt;pretty-calendar&gt;</code> that modified part of the DOM structure a little bit, applied some prettyier scoped <code>&lt;style&gt;</code> but left my JavaScript alone. With <code>&lt;shadow&gt;</code> and <code>select</code> you can do all of that, keeping just the parts of my ugly calendar that are needed to function.</p>
<p>Hopefully this has taught you a little bit about what is possible thanks to Shadow DOM. More important, however, is that you see how easy it is to experiment with emerging web technologies thanks to the awesome developer tools Chrome and Firefox provide us.</p>
<p>Send your thoughts/hacks to <em>matthew@matthewphillips.info</em>.</p>
</div></div><div class="post"><div class="post-head group"><a href="/posts/test-your-application-entry-point.html"><h1 class="post-title">Test Your Application Entry Point</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-03-26T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p>This will be short and sweet. When working on a large JavaScript application (or a small one, for that matter) you&#39;re going to have an entry point where you set up your world and get everything started. It probably looks something like this:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s1">&#39;xwidget&#39;</span><span class="p">,</span> <span class="s1">&#39;ywidget&#39;</span><span class="p">,</span> <span class="s1">&#39;routing&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">XWidget</span><span class="p">,</span> <span class="nx">YWidget</span><span class="p">,</span> <span class="nx">route</span><span class="p">){</span>
  <span class="c1">// Load everything!</span>

  <span class="c1">// Set up global state!</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">light</span><span class="o">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
    <span class="nx">time</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span>
  <span class="p">};</span>

  <span class="c1">// Initialize main widget!</span>
  <span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XWidget</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">subwidget</span><span class="o">:</span> <span class="k">new</span> <span class="nx">YWidget</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;div&gt;&lt;/div&gt;&#39;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="nx">state</span><span class="o">:</span> <span class="nx">state</span>
  <span class="p">});</span>

  <span class="c1">// Listen for routes</span>
  <span class="nx">route</span><span class="p">(</span><span class="s1">&#39;/calendar&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// Make some change to `main` probably</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>It&#39;s very easy to forget that not only is this an important chunk of code, it influences everything else that happens further down the chain in your application. <strong>Test it</strong> as though it&#39;s just as important, because it is.</p>
<p>When you begin crafting your application as a pyramid of <a href="http://dailyjs.com/2014/03/10/components-controls/">web components</a> this becomes even more critical. Using <a href="http://canjs.com/guides/Components.html">can.Component</a>&#39;s scoping rules, data you initialize in your <code>main.js</code> will trickle down and be used by any component on your page, no matter how deeply nested.</p>
<p>This is amazing in terms of crafting components that glue well together, but the downside is that the tests you created for <code>&lt;x-widget&gt;</code> are not enough, that top level file might be doing things just slightly differently.</p>
<p>The benefits of writing tests first hold as well for your application entry point. If you try writing tests after-the-fact (as I&#39;m currently doing) you&#39;ll notice that things break as your entry point file is actually dependent on something in your <code>index.html</code> file (as an example). Tests first will force you to make sure everything is as maximally modular as can be.</p>
</div></div><div class="pagination group"><a href="/page/1/" class="older">&#8592; Older</a></div></div><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.1.0/jquery.timeago.min.js" type="text/javascript"></script><script src="/scripts/main.js" type="text/javascript"></script></body></html>