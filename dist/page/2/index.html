<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" type="image/png" href="/images/cabin.png"><link href="/styles/main.css" rel="stylesheet"><title>World Wide Web Home of Matthew Phillips</title></head><body><ul class="nav group"><li class="icon-menu menu"></li><li class="nav-link red active"><a href="/" class="name">WWW Home</a></li><li class="nav-link blue"><a href="/about.html">about</a></li><li class="nav-link orange"><a href="/projects.html">projects</a></li><li class="nav-link green"><a href="/archives.html">archives</a></li></ul><div class="content"><div class="post"><div class="post-head group"><a href="/posts/responsive-computes.html"><h1 class="post-title">Responsive Computes</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-05-11T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p>Recently I was working on a template and ran into issues trying to make it responsive purely using CSS media queries. The problem is that the mark-up of the mobile view and that of the desktop were just too different. In fact, the <em>functionality</em> of the two views were a bit different as well.</p>
<p>At this point you might give up and just write up two separate templates and use media queries to hide one of them. Bootstrap even <a href="http://getbootstrap.com/css/#responsive-utilities-classes">has classes</a> for just such a case.</p>
<p>Luckily, however, there is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.matchMedia">matchMedia</a> API that brings the power of media queries to JavaScript. There&#39;s fairly broad <a href="http://caniuse.com/#feat=matchmedia">browse support</a> and even <a href="https://github.com/weblinc/media-match/blob/master/media.match.js">a polyfill</a> if you want support in older IE browsers. matchMedia allows you to use the same type of media queries in JavaScript that you can use in CSS, for example:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="kd">var</span> <span class="nx">mql</span> <span class="o">=</span> <span class="nx">matchMedia</span><span class="p">(</span><span class="s1">&#39;only screen and (max-width: 768px)&#39;</span><span class="p">);</span>
<span class="nx">mql</span><span class="p">.</span><span class="nx">matches</span> <span class="o">===</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// true if the screen is &lt;= 768px</span>
</pre></div>
</code></pre>
<p>Additionally matchMedia queries include an <code>addListener</code> function that takes a callback that will be called when the media query&#39;s status changes; meaning you can resize the browser and the media query will respond when the screen becomes less than 768px (for example).</p>
<h2><a name="live-bound-responsive-templates" class="anchor" href="#live-bound-responsive-templates"><span class="header-link"></span></a>Live-bound responsive templates</h2>
<p>If you use CanJS you&#39;re familiar with can.computes, but you might not be familiar with the <a href="http://canjs.com/docs/can.compute.html#sig_can_compute_initialValue__settings__">2nd signature</a> which allows you to create a compute from any type of event emitting object. This means we can easily turn our matchMedia query into a compute that can be used in templates:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="kd">var</span> <span class="nx">mql</span> <span class="o">=</span> <span class="nx">matchMedia</span><span class="p">(</span><span class="s1">&#39;only screen and (max-width: 768px)&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">mobile</span> <span class="o">=</span> <span class="nx">can</span><span class="p">.</span><span class="nx">compute</span><span class="p">(</span><span class="nx">mql</span><span class="p">.</span><span class="nx">matches</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">mql</span><span class="p">.</span><span class="nx">matches</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="nx">set</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// Do nothing for this one</span>
  <span class="p">},</span>
  <span class="nx">on</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">updated</span><span class="p">){</span>
    <span class="nx">mql</span><span class="p">.</span><span class="nx">addListener</span><span class="p">(</span><span class="nx">updated</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">off</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">updated</span><span class="p">){</span>
    <span class="nx">mql</span><span class="p">.</span><span class="nx">removeListener</span><span class="p">(</span><span class="nx">updated</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>The compute&#39;s <code>settings</code> object describes how to bind the compute to the media query and respond to changes. Now your templates can be responsive in a much more powerful way than what CSS allows:</p>
<pre><code class="lang-html"><div class="highlight"><pre>{{#if mobile}}
  <span class="nt">&lt;div&gt;</span>Hi there phone! Mobile navigation goes here.<span class="nt">&lt;/div&gt;</span>
{{else}}
  <span class="nt">&lt;div&gt;</span>Totally different desktop experience!<span class="nt">&lt;/div&gt;</span>
{{/if}}
</pre></div>
</code></pre>
<p>The broader lesson here is that <a href="http://canjs.com/docs/can.compute.html">can.computes</a> are crazy powerful. If you&#39;re only using them to respond to changes in your business logic you&#39;re not unlocking their full potential. The browser provides many APIs, like matchMedia, that can be bound to. Check out the <a href="http://bitovi.com/blog/2013/04/weekly-widget-compute-slider.html">video slider</a> and be inspired.</p>
</div></div><div class="post"><div class="post-head group"><a href="/posts/fun-with-shadow-dom.html"><h1 class="post-title">Fun with Shadow DOM</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-04-02T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p><strong>Update</strong>: To do this demo you first need to enable experimental web platform features <a href="chrome://flags/#enable-experimental-web-platform-features">in chrome://flags</a>.</p>
<p>Now that Chrome has shipped Shadow DOM we can start experimenting with what possibilities are going to open up to developers. Consider this a beginner/intermediate post about Shadow DOM. I assume you already know Shadow DOM is a way to &quot;hide&quot; an element&#39;s structure while opening up insertion points to its inner content.</p>
<p>With that in mind, this is a simple exercise in seeing the weirdness that is Shadow DOM. So open up a text editor and create an HTML file with these contents:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;title&gt;</span>Fun with Shadow<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;container&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;template</span> <span class="na">id=</span><span class="s">&quot;tmpl&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;style&gt;div</span> <span class="p">{</span> <span class="k">color</span><span class="o">:</span> <span class="nb">red</span><span class="p">;</span> <span class="p">}</span><span class="nt">&lt;/style&gt;</span>
  <span class="nt">&lt;div&gt;</span>Hello <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;name&quot;</span><span class="nt">&gt;</span>Matthew<span class="nt">&lt;/span&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;template</span> <span class="na">id=</span><span class="s">&quot;tmpl2&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;div&gt;</span>Welcome to the internet<span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;shadow&gt;&lt;/shadow&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</code></pre>
<p>From here on the rest of the tutorial is done from Chrome&#39;s DevTools. So open your brower and navigate to the page you just created and open the DevTools. This is a simple page with a container div and a couple of templates.</p>
<p>You should see nothing on your page at this point, but we&#39;ll change that. The element <code>&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</code> is the root element we&#39;re going to play around with so go ahead and get a reference to it.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">c</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#container&#39;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Next we&#39;re going to create this div&#39;s <a href="http://www.w3.org/TR/shadow-dom/#dfn-shadow-root">shadow root</a>. The shadow root is the place where you can append stuff to the div and not have to worry about the page&#39;s styling interfering (among other advantages).</p>
<p>Before we create the shadow root, type this into the console and hit enter:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span>
</pre></div>
</code></pre>
<p>It should return <code>null</code>, as the div doesn&#39;t have a shadow root yet. So let&#39;s go ahead and change that. Create the shadow root and keep a reference for later:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root1</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>Should return (in the console):</p>
<pre><code><div class="highlight"><pre><span class="err">#</span><span class="nx">shadow</span><span class="o">-</span><span class="nx">root</span>
</pre></div>
</code></pre>
<p>This also updates <code>c.shadowRoot</code>. Test it by doing:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root1</span> <span class="o">===</span> <span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span>
</pre></div>
</code></pre>
<p>And you&#39;ll get <code>true</code>. Awesome. Now that you have a shadow root you&#39;ll want to add stuff to it. This works like any other element. You can use <code>innerHTML</code>, <code>appendChild</code>, <code>insertBefore</code>, etc. to add content to the shadow. Let&#39;s use our first template to attach some content:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root1</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#tmpl&#39;</span><span class="p">).</span><span class="nx">content</span><span class="p">)</span>
</pre></div>
</code></pre>
<p>The immediate effect you&#39;ll see is the words &quot;Hello Matthew&quot; in red on the page. This is because the template contains a <code>&lt;style&gt;</code> tag that styles the content within the template.</p>
<p>You&#39;ll also notice that we <em>didn&#39;t</em> append the template, we appended the template&#39;s <code>content</code> property. This is a read-only property containing a document fragment of the template&#39;s content.</p>
<p>If you navigate to the DevTools&#39; <strong>Elements</strong> tab and expand the <code>#container</code> div you&#39;ll see... nothing at all. This is because shadow root is hidden by default. You can change this by going into Settings -&gt; Elements and selecting <em>Show Shadow DOM</em>. Now go back to <strong>Elements</strong> and you&#39;ll see a <code>#shadow-root</code> nested under your div. Yay!</p>
<h2><a name="deeper-down-the-rabbit-hole" class="anchor" href="#deeper-down-the-rabbit-hole"><span class="header-link"></span></a>Deeper down the rabbit hole</h2>
<p>We could stop here and you&#39;d have a good idea of what the Shadow DOM allows you to do, and how to use an element&#39;s shadow root. But we&#39;re going to take it one step further. When we created the shadow root you might have asked yourself why there is a method <code>createShadowRoot</code> in the first place. Does it mean you can have multiple shadow root&#39;s in an element? It does!</p>
<p>So let&#39;s go ahead and create a second shadow root to further our experimentation:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root2</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">createShadowRoot</span><span class="p">();</span>
</pre></div>
</code></pre>
<p>This will return a new shadow root. But what you might also notice is that the words &quot;Hello Matthew&quot; disappeared from the page. What&#39;s going on? First use the <strong>Elements</strong> tab and expand your <code>#container</code> div and there should now be two shadow roots. The first is <code>root1</code> and its contents are still there. That&#39;s good, but why can&#39;t we see it?</p>
<p>The reason is that the browser only renders the <em>last</em> shadow tree. The others are still there, you just can&#39;t see them. In your console do this:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span> <span class="o">==</span> <span class="nx">root1</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">shadowRoot</span> <span class="o">==</span> <span class="nx">root2</span>
</pre></div>
</code></pre>
<p>As you can see, the div&#39;s new shadowRoot is now <code>root2</code>. You might be asking how this is useful... I&#39;ll get to an explanation but it might be better to show you. Go ahead and attach that other template to the new root:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">root2</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#tmpl2&#39;</span><span class="p">).</span><span class="nx">content</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>Ah! The first shadow&#39;s content is back. This is because <code>#tmpl2</code> has an insertion point with <code>&lt;shadow&gt;&lt;/shadow&gt;</code>. This says &quot;insert the previous shadow here&quot;, more or less. You may also notice that the second template&#39;s div is not in red. This is because the <code>&lt;style&gt;</code> tag in the first template is scoped to only content within that template. This is the beauty of templates.</p>
<p>Back to the question, how is multiple shadow trees useful anyways? A big part of web components is going to be extending existing components. Shadow DOM provides an excellent way to do that. Let&#39;s say I created <code>&lt;super-calendar&gt;</code> and it was awesome... but ugly. You might want to come around and create <code>&lt;pretty-calendar&gt;</code> that modified part of the DOM structure a little bit, applied some prettyier scoped <code>&lt;style&gt;</code> but left my JavaScript alone. With <code>&lt;shadow&gt;</code> and <code>select</code> you can do all of that, keeping just the parts of my ugly calendar that are needed to function.</p>
<p>Hopefully this has taught you a little bit about what is possible thanks to Shadow DOM. More important, however, is that you see how easy it is to experiment with emerging web technologies thanks to the awesome developer tools Chrome and Firefox provide us.</p>
<p>Send your thoughts/hacks to <em>matthew@matthewphillips.info</em>.</p>
</div></div><div class="pagination group"><a href="/page/1/" class="newer">Newer &#8594;</a><a href="/page/3/" class="older">&#8592; Older</a></div></div><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.1.0/jquery.timeago.min.js" type="text/javascript"></script><script src="/scripts/main.js" type="text/javascript"></script></body></html>