<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" type="image/png" href="/images/cabin.png"><link href="/styles/main.css" rel="stylesheet"><title>World Wide Web Home of Matthew Phillips</title></head><body><ul class="nav group"><li class="icon-menu menu"></li><li class="nav-link red active"><a href="/" class="name">WWW Home</a></li><li class="nav-link blue"><a href="/about.html">about</a></li><li class="nav-link orange"><a href="/projects.html">projects</a></li><li class="nav-link green"><a href="/archives.html">archives</a></li></ul><div class="content"><div class="post"><div class="post-head group"><a href="/posts/test-your-application-entry-point.html"><h1 class="post-title">Test Your Application Entry Point</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-03-26T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p>This will be short and sweet. When working on a large JavaScript application (or a small one, for that matter) you&#39;re going to have an entry point where you set up your world and get everything started. It probably looks something like this:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">define</span><span class="p">([</span><span class="s1">&#39;xwidget&#39;</span><span class="p">,</span> <span class="s1">&#39;ywidget&#39;</span><span class="p">,</span> <span class="s1">&#39;routing&#39;</span><span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">XWidget</span><span class="p">,</span> <span class="nx">YWidget</span><span class="p">,</span> <span class="nx">route</span><span class="p">){</span>
  <span class="c1">// Load everything!</span>

  <span class="c1">// Set up global state!</span>
  <span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">light</span><span class="o">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span>
    <span class="nx">time</span><span class="o">:</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">()</span>
  <span class="p">};</span>

  <span class="c1">// Initialize main widget!</span>
  <span class="kd">var</span> <span class="nx">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XWidget</span><span class="p">(</span><span class="s1">&#39;body&#39;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">subwidget</span><span class="o">:</span> <span class="k">new</span> <span class="nx">YWidget</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;div&gt;&lt;/div&gt;&#39;</span><span class="p">),</span> <span class="p">{}),</span>
    <span class="nx">state</span><span class="o">:</span> <span class="nx">state</span>
  <span class="p">});</span>

  <span class="c1">// Listen for routes</span>
  <span class="nx">route</span><span class="p">(</span><span class="s1">&#39;/calendar&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="c1">// Make some change to `main` probably</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>It&#39;s very easy to forget that not only is this an important chunk of code, it influences everything else that happens further down the chain in your application. <strong>Test it</strong> as though it&#39;s just as important, because it is.</p>
<p>When you begin crafting your application as a pyramid of <a href="http://dailyjs.com/2014/03/10/components-controls/">web components</a> this becomes even more critical. Using <a href="http://canjs.com/guides/Components.html">can.Component</a>&#39;s scoping rules, data you initialize in your <code>main.js</code> will trickle down and be used by any component on your page, no matter how deeply nested.</p>
<p>This is amazing in terms of crafting components that glue well together, but the downside is that the tests you created for <code>&lt;x-widget&gt;</code> are not enough, that top level file might be doing things just slightly differently.</p>
<p>The benefits of writing tests first hold as well for your application entry point. If you try writing tests after-the-fact (as I&#39;m currently doing) you&#39;ll notice that things break as your entry point file is actually dependent on something in your <code>index.html</code> file (as an example). Tests first will force you to make sure everything is as maximally modular as can be.</p>
</div></div><div class="post"><div class="post-head group"><a href="/posts/markdown-enable-your-blog-comments-with-web-components.html"><h1 class="post-title">Markdown Enable Your Blog Comments with Web Components</h1></a><h2 class="post-date">Published&nbsp<abbr title="2014-03-01T00:00:00.000Z" class="timeago"></abbr></h2></div><div class="post-body markdown"><p>If you&#39;re like me and are excited about getting started using web components today, you might find yourself struggling coming up with practical uses that aren&#39;t the typical carousel, calendar, or <a href="http://matthewphillips.info/posts/building-an-accordion-with-can-component.html">accordion</a> widgets that we&#39;ve all written a hundred times in plain JavaScript.</p>
<p>In this article I&#39;ll walk you through the process of:</p>
<ul>
<li><p>Finding a practical use for web components.</p>
</li>
<li><p>Developing your first iteration.</p>
</li>
<li><p>Refining, deciding when components are needed and when they are just extra fluff.</p>
</li>
</ul>
<p>All of my examples will use <a href="http://canjs.com/guides/Components.html">can.Component</a> because it&#39;s available today, is stable, and has really good browser support, but are still applicable no matter what your web component framework of choice is.</p>
<h1><a name="from-concept-to-code" class="anchor" href="#from-concept-to-code"><span class="header-link"></span></a>From Concept to Code</h1>
<p>If all you&#39;re interested in is learning you can pick just about any API on the web and turn it into a web component. Or pick your favorite JavaScript library and wrap a component around it. Web components are primed to be the new jQuery plugin.</p>
<h2><a name="markdown" class="anchor" href="#markdown"><span class="header-link"></span></a>Markdown</h2>
<p>If you&#39;re a programmer you probably use markdown (or another markup generator) quite often. I&#39;m writing this post in markdown right now. The only downside is I have a Grunt task running in the background that is rerendering the html every time I save the file. What if you could write markdown and have it generate all in the browser? You want to write something like:</p>
<pre><code class="lang-html"><div class="highlight"><pre><span class="nt">&lt;markdown&gt;</span>
# Hello world!

* Oh my, **lists**
<span class="nt">&lt;/markdown&gt;</span>
</pre></div>
</code></pre>
<p>And let a library do the heavy lifting. Luckily there is a <a href="https://github.com/coreyti/showdown">Showdown</a>, a JavaScript library for turning markdown into HTML. It&#39;s pretty fantastic. So let&#39;s make a component.</p>
<p>Since Showdown does most of the heavy lifting all we need is a nice wrapper that will allow us to write Markdown inside of a tag and have it render the HTML automatically. Using can.Component we can do that easily, here&#39;s a demo:</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/TBFp6/3/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>The code should speak for itself. The <code>x-markdown</code> component (all web components should be namespaced, we use <code>x-</code> in this example) generates the HTML after it is inserted into the page. We simply listen for the <code>inserted</code> event and set the <code>&lt;content/&gt;</code> provided by the user to the <code>markdown</code> property on the component&#39;s Scope.</p>
<p>The powerful part of this example is the <code>can.compute</code>. Computes are a type of object that can listen to changes of other objects and automatically recompute themselves. If you&#39;ve used <a href="http://knockoutjs.com/documentation/observables.html">ko.observable</a> or Ember <a href="http://emberjs.com/guides/object-model/computed-properties/">computed properties</a> the idea is much the same, but can.computes are a bit more powerful (we&#39;ll get to that later).</p>
<p>The compute simple takes the value of the <code>markdown</code> property (which is set in the <code>inserted</code> event) and uses Showdown to generate the html that will be displayed.</p>
<h1><a name="using-with-blog-comments" class="anchor" href="#using-with-blog-comments"><span class="header-link"></span></a>Using with Blog Comments</h1>
<p>While cool, this example isn&#39;t that practical. In reality you&#39;ll rarely have a scenario where you need to write HTML inside of a web browser, otherwise using a static site generator is probably what you&#39;ll be using.</p>
<p>One place where you would want to generate the HTML on the fly is for blog comments. If your blog is developer-focused it makes sense to allow the reader to write comments in markdown, and have a live preview of what it will look like. So let&#39;s refactor <code>&lt;x-markdown&gt;</code> to be our live preview.</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="nx">can</span><span class="p">.</span><span class="nx">Component</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="nx">tag</span><span class="o">:</span> <span class="s1">&#39;x-markdown&#39;</span><span class="p">,</span>
  <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;&lt;div&gt;{{{html}}}&lt;/div&gt;&#39;</span><span class="p">,</span>
  <span class="nx">scope</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">html</span><span class="o">:</span> <span class="nx">can</span><span class="p">.</span><span class="nx">compute</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">markdown</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;markdown&#39;</span><span class="p">);</span>
      <span class="kd">var</span> <span class="nx">converter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">html</span> <span class="o">=</span> <span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span><span class="p">(</span><span class="nx">markdown</span><span class="p">);</span>
      <span class="k">return</span> <span class="nx">html</span><span class="p">;</span>
    <span class="p">}),</span>
    <span class="nx">markdown</span><span class="o">:</span> <span class="s1">&#39;&#39;</span>
  <span class="p">}</span>
<span class="p">});</span>
</pre></div>
</code></pre>
<p>This new version of <code>&lt;x-markdown&gt;</code> is much more succinct because we&#39;ve eliminated the <code>&lt;content/&gt;</code> portion by getting the raw markdown from a textarea. can.Component allows you to pass data (included complex objects) through an element&#39;s attribute tags. We&#39;ll use it like such: <code>&lt;x-markdown markdown=&quot;value&quot;&gt;&lt;/x-markdown&gt;</code> so that the <code>html</code> compute will be live-bound to the <code>value</code> object that we pass in.</p>
<p>Next we need to create a live-bound textarea we&#39;ll call <code>&lt;x-textarea&gt;</code>. The idea that both x-markdown and x-textarea will be live-bound to the same compute object, and any time you type into the textarea the markdown will automatically be rerendered in the preview window. Demo time:</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/TBFp6/6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>Try out the fiddle (Click on the <strong>Result</strong> link) and see for yourself how the preview updates as you type. The secret sauce here is that we are using <code>can-value</code> to bind the textarea&#39;s <code>value</code> to our scope property also called <code>value</code>. can-value works on the element&#39;s <code>change</code> event, which for most types of forms is fine, but in our case we need the preview to update as you type, so we&#39;ve added a <code>keyup</code> event that simply triggers the textarea&#39;s change event as the user types. Simple!</p>
<h1><a name="when-not-to-web-component" class="anchor" href="#when-not-to-web-component"><span class="header-link"></span></a>When not to Web Component</h1>
<p>Awesome, we&#39;ve built a live-bound markdown enabled comment system. In less than 30 lines of code. However you might notice that the <code>&lt;x-textarea&gt;</code> isn&#39;t really doing much at all. It simply turns a normal textarea into a live-bound one.</p>
<p>However in reality textareas <em>really are</em> live-bound, they use the normal DOM events to update their values. So all we are using the <code>&lt;x-textarea&gt;</code> for in practice is to turn the DOM events into can events. Luckily <a href="http://canjs.com/docs/can.compute.html">can.compute</a> already has a way of doing this, so we don&#39;t need the <code>x-textarea</code> at all.</p>
<p>can.compute can take a set of arguments that includes an element, the property to bind to, and an event to bind to. We&#39;ll use it like:</p>
<pre><code class="lang-javascript"><div class="highlight"><pre><span class="kd">var</span> <span class="nx">markdown</span> <span class="o">=</span> <span class="nx">can</span><span class="p">.</span><span class="nx">compute</span><span class="p">(</span><span class="nx">textarea</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="s1">&#39;keyup&#39;</span><span class="p">);</span>
</pre></div>
</code></pre>
<p>This allows us to move our textarea outside of the script tag (since we&#39;re getting rid of the component) but still have a live-bound value between the textarea and our <code>x-markdown</code> preview. See the demo below.</p>
<h2><a name="demo" class="anchor" href="#demo"><span class="header-link"></span></a>Demo</h2>
<iframe width="100%" height="300" src="http://jsfiddle.net/TBFp6/5/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>Hopefully I&#39;ve demonstrated the process of coming up with an idea for a component (essentially an encapsulated piece of HTML with JavaScript interactivity) and refining it until you are left with only the bits of code that you need. We&#39;ve created a Markdown-enabled blog commenting system is only 18 lines of code. Let it be inspiration for your next component. Can you do better, how about an MDN reference widget?</p>
</div></div><div class="pagination group"><a href="/page/2/" class="newer">Newer &#8594;</a><a href="/page/4/" class="older">&#8592; Older</a></div></div><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.2/jquery.min.js" type="text/javascript"></script><script src="//cdnjs.cloudflare.com/ajax/libs/jquery-timeago/1.1.0/jquery.timeago.min.js" type="text/javascript"></script><script src="/scripts/main.js" type="text/javascript"></script></body></html>