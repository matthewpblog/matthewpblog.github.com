<!DOCTYPE html>
<html>
<head>
  <base href="..">
    <meta charset="utf-8">
      <title>Building a gist-based blogging tool | Matthew Phillips</title>

    <meta name="author" content="Matthew Phillips">
    <meta name="date" content="2014-07-02">

    <link rel="stylesheet" href="styles//normalize.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Code+Pro:300,600">
    <link rel="stylesheet" href="styles/screen.css">
    <link rel="stylesheet" href="styles/github.css">
</head>
<body>
  <section class="content">
    <header>
      <h1 id="gistid"><a href="https://gist.github.com/beb161d681dab3b028f0">gist #beb161d681dab3b028f0</a></h1>
      <h2 id="description" class="instapaper_title entry-title">
        <span id="prompt"><span class="host">matthew@local</span><span>:</span><span class="tilde">~</span><span class="dollar">$<?span></span>
        <span> echo 'Building a gist-based blogging tool'</span>
      </h2>
    </header>

    <div id="gistbody" class="instapaper_body entry-content">
      <article>
        <h2 id="motivation">Motivation</h2>
<p>For the past several years I have been using <a href="http://www.cabinjs.com/">Cabin</a> for my personal blog. Cabin works like most other static site generators in the vein of <a href="http://jekyllrb.com/">Jekyll</a>; you write your posts in markdown in a posts folder, your templates in a template folder, run a script and it generates the HTML for your blog. Simple enough.</p>
<p>The problem I&#39;ve always had with this setup is that it has just enough friction that I wind up not blogging as often as I would like. During your &quot;draft&quot; stage you still have most of the same steps as when you finally deploy. You have to clone your site, create a branch to write a new post in, write, commit and push. When I have inspiration to write I want to just write, not manage a project.</p>
<p>So what I usually do is write my posts in Gist or Google Docs and then move them to my site project when I&#39;m done. I started thinking, what if I could remove the blog engine entirely?</p>
<p>My first thought was to set up a server that just served Gists directly. To this end I set up an <a href="http://expressjs.com/">Express</a> server that did exactly that.  I had a Gist that I <a href="https://gist.github.com/matthewp/695b163d39f68ec73678">used as my index</a> of all Gists I wanted to be served. The front page was just a list of links to each article with the url containing the Gist id.</p>
<p>To make this work with my existing posts I needed to convert them to gists. This was more work than I expected. Cabin uses a non-standard front-matter format. Most blog engines use YAML but Cabin uses a JavaScript-like syntax.  I would have expected it to be JSON but it&#39;s not, the keys are not strings. To figure out how they did this I had to dig through their source and found it <a href="https://github.com/CabinJS/grunt-pages/blob/4cd264fce21fb8d90198edadeccb3961b37537bc/tasks/pages.js#L269">buried in a Grunt task</a>. It was easy enough to extract this code and reuse it for my needs. Each gist contains the markdown content (minus the front-matter) and a <code>metadata.json</code> file containing the front-matter (now json).</p>
<p>This all worked well enough but I felt uneasy about pulling directly from Gist to serve the blog posts. It just felt wasteful, even if I included caching that prevented it from fetching the gists on each requests. Additional it broke my old links. I played around with the idea of having a &quot;slug&quot; that would serve as the id for a post, but this meant I would need to pull that index gist to find out which gist id the slug referred to. Again, not terrible, just more code than I wanted.</p>
<h2 id="one-thing-well">One thing well</h2>
<p>I&#39;ve always been a fan of the Unix philosophy of doing one thing well, so I started to think why not construct the posts using basic cli tools already available. You can easily pull down a gist using the GitHub API and then use a series of other tools to generate the html. The full bash script can be seen below, but here&#39;s the pseudo-code of what happens:</p>
<pre><code class="hljs shell">curl https://api.github.com/gists/$GIST_ID |<span class="hljs-string"> \
jq '.files[.files </span>|<span class="hljs-string"> keys[0]].content' </span>|<span class="hljs-string"> \
marked </span>|<span class="hljs-string"> hb -i post.handlebars</span>
</code></pre>
<p>It&#39;s pretty simple, let me explain what easy step does:</p>
<h3 id="curl-api-github-com">curl api.github.com</h3>
<p>Luckily pulling down gists is really easy with the GitHub API. Unless you are doing it a lot, and likely programmatically, you don&#39;t even need to set up an auth token, but you can do this if you want. It returns a JSON containing a lot of data, but we really just want the post content.</p>
<h3 id="jq">jq</h3>
<p><a href="http://stedolan.github.io/jq/">jq</a> is an amazing command-line JSON parser. In its simplest form jq can be used as a prettifier, but you can do advanced stuff to extract just the parts that you need.</p>
<p>Its power is shown here because the gist JSON structure makes it slightly difficult to extract the post content. This is because instead of having an array of <code>files</code> it has an object where the file name is the key. This is fine for when you know the name of a file, but in my case I just wanted to assume that the first file in a gist is the markdown.</p>
<p>Lucky jq can easily handle this. Consider the structure is like this:</p>
<pre><code class="hljs json">{
  "<span class="hljs-attribute">files</span>": <span class="hljs-value">{
    "<span class="hljs-attribute">foo.md</span>": <span class="hljs-value">{
      "<span class="hljs-attribute">something</span>": <span class="hljs-value"><span class="hljs-string">"else"</span></span>,
      "<span class="hljs-attribute">content</span>": <span class="hljs-value"><span class="hljs-string">"# Title\nsome test\n* a list"</span>
    </span>}
  </span>}
</span>}
</code></pre>
<p>With jq you can run <code>jq &#39;.files[.files | keys[0]].content&#39;</code>. This gets <code>.files</code> and then uses the <code>keys</code> function to get all of the keys of the files object and uses the key indexed 0 to get the &quot;foo.md&quot; object and finally we want <code>.content</code> which is the markdown.</p>
<h3 id="marked">marked</h3>
<p><a href="https://github.com/chjj/marked">marked</a> is the premier markdown compiler (to html) for JavaScript. Luckily it include a command-line tool that takes markdown from stdin and spits out html to stdout. Perfect.</p>
<p>One downside is that it doesn&#39;t include a way to highlight code. If using the Node.js API you can set options which includes using a highlighter of your choice. I usually use <a href="https://highlightjs.org/">hightlight.js</a>. With that the code would be something like:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">"marked"</span>);

marked.setOptions({
  highlight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">"highlight.js"</span>).highlightAuto(code).value;
  }
});
</code></pre>
<p>This is an <a href="https://github.com/chjj/marked/issues/110">open issue</a> about how this could be used with the cli. My suggestion was to provide a module that exports options. This way you could write the above code as:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">"marked"</span>);

<span class="hljs-built_in">module</span>.exports = {
  highlight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">"highlight.js"</span>).highlightAuto(code).value;
  }
};
</code></pre>
<p>And feed that option into the <code>marked</code> cli.  It becomes:</p>
<pre><code><span class="hljs-keyword">cat</span> my-post.md | marked --<span class="hljs-keyword">options</span> /path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">options</span>.js
</code></pre><p>They <a href="https://github.com/chjj/marked/pull/613">haven&#39;t yet accepted</a> this change but I do have it working in my own fork.</p>
<h3 id="hb">hb</h3>
<p>Having gone from gist into json into markdown into html, the final step is to run the produced html through a template engine so that the article is contained within a full page. Since I&#39;m already very familiar with the Mustache syntax in my day job I decided to use <a href="http://handlebarsjs.com/">handlebars</a> for templates. A simple post template can be:</p>
<pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span></span><span class="hljs-expression">{{<span class="hljs-variable">title</span>}}</span><span class="xml"> | My Blog<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"some.css"</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">article</span>&gt;</span>
    </span><span class="hljs-expression">{{{<span class="hljs-variable">content</span>}}</span><span class="xml">}
  <span class="hljs-tag">&lt;/<span class="hljs-title">article</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></span>
</code></pre>
<p>We just need to feed the generated html through this template to generate a post. I couldn&#39;t find a project that did exactly what I need; take json and a template and produce html, so I forked a close-enough project and adjusted it, creating <a href="https://www.npmjs.com/package/handlebars-render">handlebars-render</a> which does this.  You can use it like:</p>
<pre><code class="hljs shell">echo '{<span class="hljs-string">"foo"</span>: <span class="hljs-string">"bar"</span>}' <span class="hljs-string">| hb -i page.handlebars</span>
</code></pre>
<p>The output of <strong>marked</strong> is fed into this script. I use a <code>metadata.json</code> file in my gist that provices the post date, title, and tags (which I don&#39;t currently support, but could in the future).  Usage winds up like:</p>
<pre><code class="hljs shell"><span class="hljs-keyword">DATA</span>=<span class="hljs-string">"{\"</span>id\<span class="hljs-string">": <span class="hljs-variable">$ID</span>, \"</span>title\<span class="hljs-string">": <span class="hljs-variable">$TITLE</span>, \"</span>content\<span class="hljs-string">": <span class="hljs-variable">$HTML</span>, \"</span>metadata\<span class="hljs-string">": <span class="hljs-variable">$METADATA</span>, \"</span>date\<span class="hljs-string">": <span class="hljs-variable">$DATE</span>}"</span>
echo <span class="hljs-variable">$DATA</span> | hb -i templates/post.handlebars
</code></pre>
<p>There&#39;s probably a better way to create a json string (perhaps with jq) but this works well enough for my needs.</p>
<h2 id="putting-it-all-together">Putting it all together</h2>
<p>And that&#39;s it! With those core scripts I can easily put everything together that generates html. My script is simple:</p>
<pre><code class="hljs shell"><span class="hljs-shebang">#!/bin/bash</span>
GIST_ID=<span class="hljs-variable">$1</span>

IFS=<span class="hljs-string">' '</span>

GIST_JSON=`curl -H <span class="hljs-string">"Authorization: token <span class="hljs-variable">$GITHUB_TOKEN</span>"</span> <span class="hljs-operator">-s</span> https://api.github.com/gists/<span class="hljs-variable">$GIST_ID</span>`

CONTENT=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$GIST_JSON</span> | jq <span class="hljs-string">'.files[.files | keys[0]].content'</span>`
METADATA=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$GIST_JSON</span> | jq -r <span class="hljs-string">'.files["metadata.json"].content'</span>`
HTML=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$CONTENT</span> | jq -r <span class="hljs-string">'.'</span> | marked --options marked_options.js | jq <span class="hljs-operator">-s</span> -R <span class="hljs-string">'.'</span>`

<span class="hljs-comment"># Get the title either from metadata.title or .description</span>
TITLE=`[[ <span class="hljs-string">"<span class="hljs-variable">$METADATA</span>"</span> == <span class="hljs-string">"null"</span> ]] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$GIST_JSON</span> | jq <span class="hljs-string">'.description'</span> || <span class="hljs-built_in">echo</span> <span class="hljs-variable">$METADATA</span> | jq <span class="hljs-string">'.title'</span>`
ID=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$GIST_JSON</span> | jq <span class="hljs-string">".id"</span>`
DATE=\<span class="hljs-string">"`[[ "</span><span class="hljs-variable">$METADATA</span><span class="hljs-string">" == "</span>null<span class="hljs-string">" ]] &amp;&amp; echo "</span>foo<span class="hljs-string">" || echo <span class="hljs-variable">$METADATA</span> | jq -r '.date' | xargs -I{} gdate -d {} + Y- m- d`\"

DATA="</span>{\<span class="hljs-string">"id\": <span class="hljs-variable">$ID</span>, \"title\": <span class="hljs-variable">$TITLE</span>, \"content\": <span class="hljs-variable">$HTML</span>, \"metadata\": <span class="hljs-variable">$METADATA</span>, \"date\": <span class="hljs-variable">$DATE</span>}"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-variable">$DATA</span> | hb -i templates/post.handlebars
</code></pre>
<p>There&#39;s some backwards compatible stuff happening in the script or it would be even shorter; but even as it stands I&#39;ll take a fairly easy to read 20 LOC script as the basis for my blog any day. All that is needed is a environment variable <code>GITHUB_TOKEN</code> and a gist id provided as the first parameter and the script will spit out html.</p>
<p>I&#39;ve got other scripts that do things like generate the index.html page and a script that will generate all posts (I keep a <code>posts</code> file that just lists the gist id and slug for these purposes). </p>
<p>I&#39;m relatively happy that I&#39;ve been able to create an extremely light weight &quot;static site generate&quot; that&#39;s just scripted small utilities.</p>


      </article>
    </div>
    <footer style="display: block">
      <p>Matthew Phillips</p>
    </footer>
  </section>
</body>
</html>
