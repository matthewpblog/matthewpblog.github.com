<!DOCTYPE html>
<html>
<head>
  <base href="..">
    <meta charset="utf-8">
      <title>Building a gist-based blogging tool | Matthew Phillips</title>

    <meta name="author" content="Matthew Phillips">
    <meta name="date" content="2014-07-02">

    <link rel="stylesheet" href="styles//normalize.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Code+Pro:300,600">
    <link rel="stylesheet" href="styles/screen.css">
    <link rel="stylesheet" href="styles/github.css">
</head>
<body>
  <section class="content">
    <header>
      <h1 id="gistid"><a href="https://gist.github.com/beb161d681dab3b028f0">gist #beb161d681dab3b028f0</a></h1>
      <h2 id="description" class="instapaper_title entry-title">Building a gist-based blogging tool</h2>
    </header>

    <div id="gistbody" class="instapaper_body entry-content">
      <article>
        <h2 id="motivation">Motivation</h2>
<p>For the past several years I have been using <a href="http://www.cabinjs.com/">Cabin</a> for my personal blog. Cabin works like most other static site generators in the vein of <a href="http://jekyllrb.com/">Jekyll</a>; you write your posts in markdown in a posts folder, your templates in a template folder, run a script and it generates the HTML for your blog. Simple enough.</p>
<p>The problem I&#39;ve always had with this setup is that it has just enough friction that I wind up not blogging as often as I would like. During your &quot;draft&quot; stage you still have most of the same steps as when you finally deploy. You have to clone your site, create a branch to write a new post in, write, commit and push. When I have inspiration to write I want to just write, not manage a project.</p>
<p>So what I usually do is write my posts in Gist or Google Docs and then move them to my site project when I&#39;m done. I started thinking, what if I could remove the blog engine entirely?</p>
<p>My first thought was to set up a server that just served Gists directly. To this end I used <a href="http://expressjs.com/">Express</a> that did exactly that.  I had a Gist that I <a href="https://gist.github.com/matthewp/695b163d39f68ec73678">used as my index</a> of all Gists I wanted to be served. The front page was just a list of links to each article with the url containing the Gist id.</p>
<p>To make this work with my existing posts I needed to convert them to gists. This was more work than I expected. Cabin uses a non-standard front-matter format. Most blog engines use YAML but Cabin uses a JavaScript-like syntax.  I would have expected it to be JSON but it&#39;s not, the keys are not strings. To figure out how they did this I had to dig through their source and found it <a href="https://github.com/CabinJS/grunt-pages/blob/4cd264fce21fb8d90198edadeccb3961b37537bc/tasks/pages.js#L269">buried in a Grunt task</a>. It was easy enough to extract this code and reuse it for my needs. Each gist contains the markdown content (minus the front-matter) and a <code>metadata.json</code> file containing the front-matter (now json).</p>
<p>This all worked well enough but I felt uneasy about pulling directly from Gist to serve the blog posts. It just felt wasteful, even if I included caching that prevented it from fetching the gists on each requests. Additional it broke my old links. I played around with the idea of having a &quot;slug&quot; that would serve as the id for a post, but this meant I would need to pull that index gist to find out which gist id the slug referred to. Again, not terrible, just more code than I wanted.</p>
<h2 id="one-thing-well">One thing well</h2>
<p>I&#39;ve always been a fan of the Unix philosophy of doing one thing well, so I started to think why not construct the posts using basic cli tools already available. You can easily pull down a gist using the GitHub API and then use a series of other tools to generate the html. The full bash script can be seen below, but here&#39;s the pseudo-code of what happens:</p>
<pre><code>curl https://api.github.com/gists/$GIST_ID |<span class="hljs-string"> jq '.files[.files </span>|<span class="hljs-string"> keys[0]].content' </span>|<span class="hljs-string"> \
marked </span>|<span class="hljs-string"> hb -i post.handlebars</span>
</code></pre><p>It&#39;s pretty simple, let me explain what easy step does:</p>
<h3 id="curl-api-github-com">curl api.github.com</h3>
<p>Luckily pulling down gists is really easy with the GitHub API. Unless you are doing it a lot, programmatically, you don&#39;t even need to set up an auth token, but you can do this if you want. It returns a JSON containing a lot of data, but we really just want the post content.</p>
<h3 id="jq">jq</h3>
<p><a href="http://stedolan.github.io/jq/">jq</a> is an awesome command-line JSON parser. In it&#39;s simplest form jq can be used as a prettifier, but you can do advanced stuff to extract just the parts that you need.</p>
<p>It&#39;s power is shown here because the gist JSON structure makes it slightly difficult to extract the post content. This is because instead of having an array of <code>files</code> it has an object where the file name is the key. This is fine for when you know the name of a file, but in my case I just wanted to assume that the first file in a gist is the markdown.</p>
<p>Lucky jq can easily handle this. Consider the structure is like this:</p>
<pre><code class="hljs json">{
  "<span class="hljs-attribute">files</span>": <span class="hljs-value">{
    "<span class="hljs-attribute">foo.md</span>": <span class="hljs-value">{
      "<span class="hljs-attribute">something</span>": <span class="hljs-value"><span class="hljs-string">"else"</span></span>,
      "<span class="hljs-attribute">content</span>": <span class="hljs-value"><span class="hljs-string">"# Title\nsome test\n* a list"</span>
    </span>}
  </span>}
</span>}
</code></pre>
<p>With jq you can do <code>jq &#39;.files[.files | keys[0]].content&#39;</code>. This gets <code>.files</code> and then uses the <code>keys</code> function to get all of the keys of the files object and uses the key indexed 0 to get the &quot;foo.md&quot; object and finally we want <code>.content</code> which is the markdown.</p>
<h3 id="marked">marked</h3>
<p><a href="https://github.com/chjj/marked">marked</a> is the premier markdown compiler (to html) for JavaScript. Luckily it include a command-line tool that takes markdown from stdin and spits out html to stdout. Perfect.</p>
<p>One downside is that it doesn&#39;t include a way to highlight code. If using the Node.js API you can set options which includes using a highlighter of your choice. I usually use <a href="https://highlightjs.org/">hightlight.js</a>. With that it would be something like:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">"marked"</span>);

marked.setOptions({
  highlight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">"highlight.js"</span>).highlightAuto(code).value;
  }
});
</code></pre>
<p>This is an <a href="https://github.com/chjj/marked/issues/110">open issue</a> about how this could be used with the cli. My suggestion was to provide a module that exports options. This way you could write the above code as:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">"marked"</span>);

<span class="hljs-built_in">module</span>.exports = {
  highlight: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">"highlight.js"</span>).highlightAuto(code).value;
  }
};
</code></pre>
<p>And feed that option into the <code>marked</code> cli.  It becomes:</p>
<pre><code><span class="hljs-keyword">cat</span> my-post.md | marked --<span class="hljs-keyword">options</span> /path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">options</span>.js
</code></pre><p>They haven&#39;t yet accepted this change but I do have it working in my own fork.</p>
<h3 id="hb">hb</h3>
<p>Having gone from gist into json into markdown into html, the final step is to run the produced html through a template engine so that the article is contained within a full page. Since I&#39;m already very familiar with the Mustache syntax in my day job I decided to use <a href="http://handlebarsjs.com/">handlebars</a> for templates. A simple post template can be:</p>
<pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span></span><span class="hljs-expression">{{<span class="hljs-variable">title</span>}}</span><span class="xml"> | My Blog<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"some.css"</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">article</span>&gt;</span>
    </span><span class="hljs-expression">{{{<span class="hljs-variable">content</span>}}</span><span class="xml">}
  <span class="hljs-tag">&lt;/<span class="hljs-title">article</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></span>
</code></pre>
<p>We just need to feed the generated html through this template to generate a post.</p>


      </article>
    </div>
    <footer style="display: block">
      <p>Matthew Phillips</p>
    </footer>
  </section>
</body>
</html>
