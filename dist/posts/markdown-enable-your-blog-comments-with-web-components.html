<!DOCTYPE html>
<html>
<head>
  <base href="..">
    <meta charset="utf-8">
      <title>Markdown Enable Your Blog Comments with Web Components | Matthew Phillips</title>

    <meta name="author" content="Matthew Phillips">
    <meta name="date" content="2014-02-28">

    <link rel="stylesheet" href="styles//normalize.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Code+Pro:300,600">
    <link rel="stylesheet" href="styles/screen.css">
    <link rel="stylesheet" href="styles/github.css">
</head>
<body>
  <section class="content">
    <header>
      <h1 id="gistid"><a href="https://gist.github.com/b9ed112bbd6db52fd033">gist #b9ed112bbd6db52fd033</a></h1>
      <h3>
        <span id="prompt"><span class="host">matthew@local</span><span>:</span><span class="tilde">~</span><span class="dollar">$<?span></span>
          <span> cat markdown-enable-your-blog-comments-with-web-components.markdown</span>
      </h3>
      <h2 id="description" class="instapaper_title entry-title">Markdown Enable Your Blog Comments with Web Components</h2>
    </header>

    <div id="gistbody" class="instapaper_body entry-content">
      <article>
        <p>If you&#39;re like me and are excited about getting started using web components today, you might find yourself struggling coming up with practical uses that aren&#39;t the typical carousel, calendar, or <a href="http://matthewphillips.info/posts/building-an-accordion-with-can-component.html">accordion</a> widgets that we&#39;ve all written a hundred times in plain JavaScript.</p>
<p>In this article I&#39;ll walk you through the process of:</p>
<ul>
<li><p>Finding a practical use for web components.</p>
</li>
<li><p>Developing your first iteration.</p>
</li>
<li><p>Refining, deciding when components are needed and when they are just extra fluff.</p>
</li>
</ul>
<p>All of my examples will use <a href="http://canjs.com/guides/Components.html">can.Component</a> because it&#39;s available today, is stable, and has really good browser support, but are still applicable no matter what your web component framework of choice is.</p>
<h1 id="from-concept-to-code">From Concept to Code</h1>
<p>If all you&#39;re interested in is learning you can pick just about any API on the web and turn it into a web component. Or pick your favorite JavaScript library and wrap a component around it. Web components are primed to be the new jQuery plugin.</p>
<h2 id="markdown">Markdown</h2>
<p>If you&#39;re a programmer you probably use markdown (or another markup generator) quite often. I&#39;m writing this post in markdown right now. The only downside is I have a Grunt task running in the background that is rerendering the html every time I save the file. What if you could write markdown and have it generate all in the browser? You want to write something like:</p>
<pre><code class="hljs html"><span class="hljs-variable">&lt;markdown&gt;</span>
<span class="hljs-comment"># Hello world!</span>

<span class="hljs-keyword">*</span> Oh my, <span class="hljs-keyword">*</span><span class="hljs-keyword">*</span>lists<span class="hljs-keyword">*</span><span class="hljs-keyword">*</span>
<span class="hljs-variable">&lt;/markdown&gt;</span>
</code></pre>
<p>And let a library do the heavy lifting. Luckily there is a <a href="https://github.com/coreyti/showdown">Showdown</a>, a JavaScript library for turning markdown into HTML. It&#39;s pretty fantastic. So let&#39;s make a component.</p>
<p>Since Showdown does most of the heavy lifting all we need is a nice wrapper that will allow us to write Markdown inside of a tag and have it render the HTML automatically. Using can.Component we can do that easily, here&#39;s a demo:</p>
<h2 id="demo">Demo</h2>
<iframe width="100 " height="300" src="http://jsfiddle.net/TBFp6/3/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>The code should speak for itself. The <code>x-markdown</code> component (all web components should be namespaced, we use <code>x-</code> in this example) generates the HTML after it is inserted into the page. We simply listen for the <code>inserted</code> event and set the <code>&lt;content/&gt;</code> provided by the user to the <code>markdown</code> property on the component&#39;s Scope.</p>
<p>The powerful part of this example is the <code>can.compute</code>. Computes are a type of object that can listen to changes of other objects and automatically recompute themselves. If you&#39;ve used <a href="http://knockoutjs.com/documentation/observables.html">ko.observable</a> or Ember <a href="http://emberjs.com/guides/object-model/computed-properties/">computed properties</a> the idea is much the same, but can.computes are a bit more powerful (we&#39;ll get to that later).</p>
<p>The compute simple takes the value of the <code>markdown</code> property (which is set in the <code>inserted</code> event) and uses Showdown to generate the html that will be displayed.</p>
<h1 id="using-with-blog-comments">Using with Blog Comments</h1>
<p>While cool, this example isn&#39;t that practical. In reality you&#39;ll rarely have a scenario where you need to write HTML inside of a web browser, otherwise using a static site generator is probably what you&#39;ll be using.</p>
<p>One place where you would want to generate the HTML on the fly is for blog comments. If your blog is developer-focused it makes sense to allow the reader to write comments in markdown, and have a live preview of what it will look like. So let&#39;s refactor <code>&lt;x-markdown&gt;</code> to be our live preview.</p>
<pre><code class="hljs javascript">can.<span class="hljs-type">Component</span>.extend({
  tag: 'x-markdown',
  <span class="hljs-keyword">template</span>: '&lt;<span class="hljs-keyword">div</span>&gt;{{{html}}}&lt;/<span class="hljs-keyword">div</span>&gt;',
  scope: {
    html: can.compute(function() {
      <span class="hljs-keyword">var</span> markdown = this.attr('markdown');
      <span class="hljs-keyword">var</span> <span class="hljs-keyword">converter</span> = new <span class="hljs-type">Showdown</span>.<span class="hljs-keyword">converter</span>();
      <span class="hljs-keyword">var</span> html = <span class="hljs-keyword">converter</span>.makeHtml(markdown);
      <span class="hljs-keyword">return</span> html;
    }),
    markdown: ''
  }
});
</code></pre>
<p>This new version of <code>&lt;x-markdown&gt;</code> is much more succinct because we&#39;ve eliminated the <code>&lt;content/&gt;</code> portion by getting the raw markdown from a textarea. can.Component allows you to pass data (included complex objects) through an element&#39;s attribute tags. We&#39;ll use it like such: <code>&lt;x-markdown markdown=&quot;value&quot;&gt;&lt;/x-markdown&gt;</code> so that the <code>html</code> compute will be live-bound to the <code>value</code> object that we pass in.</p>
<p>Next we need to create a live-bound textarea we&#39;ll call <code>&lt;x-textarea&gt;</code>. The idea that both x-markdown and x-textarea will be live-bound to the same compute object, and any time you type into the textarea the markdown will automatically be rerendered in the preview window. Demo time:</p>
<h2 id="demo">Demo</h2>
<iframe width="100 " height="300" src="http://jsfiddle.net/TBFp6/6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>Try out the fiddle (Click on the <strong>Result</strong> link) and see for yourself how the preview updates as you type. The secret sauce here is that we are using <code>can-value</code> to bind the textarea&#39;s <code>value</code> to our scope property also called <code>value</code>. can-value works on the element&#39;s <code>change</code> event, which for most types of forms is fine, but in our case we need the preview to update as you type, so we&#39;ve added a <code>keyup</code> event that simply triggers the textarea&#39;s change event as the user types. Simple!</p>
<h1 id="when-not-to-web-component">When not to Web Component</h1>
<p>Awesome, we&#39;ve built a live-bound markdown enabled comment system. In less than 30 lines of code. However you might notice that the <code>&lt;x-textarea&gt;</code> isn&#39;t really doing much at all. It simply turns a normal textarea into a live-bound one.</p>
<p>However in reality textareas <em>really are</em> live-bound, they use the normal DOM events to update their values. So all we are using the <code>&lt;x-textarea&gt;</code> for in practice is to turn the DOM events into can events. Luckily <a href="http://canjs.com/docs/can.compute.html">can.compute</a> already has a way of doing this, so we don&#39;t need the <code>x-textarea</code> at all.</p>
<p>can.compute can take a set of arguments that includes an element, the property to bind to, and an event to bind to. We&#39;ll use it like:</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> markdown = can.compute(textarea, <span class="hljs-string">'value'</span>, <span class="hljs-string">'keyup'</span>);
</code></pre>
<p>This allows us to move our textarea outside of the script tag (since we&#39;re getting rid of the component) but still have a live-bound value between the textarea and our <code>x-markdown</code> preview. See the demo below.</p>
<h2 id="demo">Demo</h2>
<iframe width="100 " height="300" src="http://jsfiddle.net/TBFp6/5/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>Hopefully I&#39;ve demonstrated the process of coming up with an idea for a component (essentially an encapsulated piece of HTML with JavaScript interactivity) and refining it until you are left with only the bits of code that you need. We&#39;ve created a Markdown-enabled blog commenting system is only 18 lines of code. Let it be inspiration for your next component. Can you do better, how about an MDN reference widget?</p>


      </article>
    </div>
    <footer style="display: block">
      <p>Matthew Phillips</p>
    </footer>
  </section>
</body>
</html>
