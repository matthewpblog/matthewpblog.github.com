<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript Canjs Can.Component Web Components on Matthew Phillips</title>
    <link>https://matthewphillips.info/categories/javascript-canjs-can.component-web-components</link>
    <description>Recent content in Javascript Canjs Can.Component Web Components on Matthew Phillips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Mar 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://matthewphillips.info/categories/javascript-canjs-can.component-web-components.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Markdown Enable Your Blog Comments with Web Components</title>
      <link>https://matthewphillips.info/posts/markdown-enable-your-blog-comments-with-web-components.html</link>
      <pubDate>Sat, 01 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://matthewphillips.info/posts/markdown-enable-your-blog-comments-with-web-components.html</guid>
      <description>

&lt;p&gt;If you&amp;rsquo;re like me and are excited about getting started using web components today, you might find yourself struggling coming up with practical uses that aren&amp;rsquo;t the typical carousel, calendar, or &lt;a href=&#34;http://matthewphillips.info/posts/building-an-accordion-with-can-component.html&#34;&gt;accordion&lt;/a&gt; widgets that we&amp;rsquo;ve all written a hundred times in plain JavaScript.&lt;/p&gt;

&lt;p&gt;In this article I&amp;rsquo;ll walk you through the process of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Finding a practical use for web components.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Developing your first iteration.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Refining, deciding when components are needed and when they are just extra fluff.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of my examples will use &lt;a href=&#34;http://canjs.com/guides/Components.html&#34;&gt;can.Component&lt;/a&gt; because it&amp;rsquo;s available today, is stable, and has really good browser support, but are still applicable no matter what your web component framework of choice is.&lt;/p&gt;

&lt;h1 id=&#34;from-concept-to-code:91190a79664036955176de2fc388a61f&#34;&gt;From Concept to Code&lt;/h1&gt;

&lt;p&gt;If all you&amp;rsquo;re interested in is learning you can pick just about any API on the web and turn it into a web component. Or pick your favorite JavaScript library and wrap a component around it. Web components are primed to be the new jQuery plugin.&lt;/p&gt;

&lt;h2 id=&#34;markdown:91190a79664036955176de2fc388a61f&#34;&gt;Markdown&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re a programmer you probably use markdown (or another markup generator) quite often. I&amp;rsquo;m writing this post in markdown right now. The only downside is I have a Grunt task running in the background that is rerendering the html every time I save the file. What if you could write markdown and have it generate all in the browser? You want to write something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;markdown&amp;gt;
# Hello world!

* Oh my, **lists**
&amp;lt;/markdown&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let a library do the heavy lifting. Luckily there is a &lt;a href=&#34;https://github.com/coreyti/showdown&#34;&gt;Showdown&lt;/a&gt;, a JavaScript library for turning markdown into HTML. It&amp;rsquo;s pretty fantastic. So let&amp;rsquo;s make a component.&lt;/p&gt;

&lt;p&gt;Since Showdown does most of the heavy lifting all we need is a nice wrapper that will allow us to write Markdown inside of a tag and have it render the HTML automatically. Using can.Component we can do that easily, here&amp;rsquo;s a demo:&lt;/p&gt;

&lt;h2 id=&#34;demo:91190a79664036955176de2fc388a61f&#34;&gt;Demo&lt;/h2&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;300&#34; src=&#34;http://jsfiddle.net/TBFp6/3/embedded/&#34; allowfullscreen=&#34;allowfullscreen&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;The code should speak for itself. The &lt;code&gt;x-markdown&lt;/code&gt; component (all web components should be namespaced, we use &lt;code&gt;x-&lt;/code&gt; in this example) generates the HTML after it is inserted into the page. We simply listen for the &lt;code&gt;inserted&lt;/code&gt; event and set the &lt;code&gt;&amp;lt;content/&amp;gt;&lt;/code&gt; provided by the user to the &lt;code&gt;markdown&lt;/code&gt; property on the component&amp;rsquo;s Scope.&lt;/p&gt;

&lt;p&gt;The powerful part of this example is the &lt;code&gt;can.compute&lt;/code&gt;. Computes are a type of object that can listen to changes of other objects and automatically recompute themselves. If you&amp;rsquo;ve used &lt;a href=&#34;http://knockoutjs.com/documentation/observables.html&#34;&gt;ko.observable&lt;/a&gt; or Ember &lt;a href=&#34;http://emberjs.com/guides/object-model/computed-properties/&#34;&gt;computed properties&lt;/a&gt; the idea is much the same, but can.computes are a bit more powerful (we&amp;rsquo;ll get to that later).&lt;/p&gt;

&lt;p&gt;The compute simple takes the value of the &lt;code&gt;markdown&lt;/code&gt; property (which is set in the &lt;code&gt;inserted&lt;/code&gt; event) and uses Showdown to generate the html that will be displayed.&lt;/p&gt;

&lt;h1 id=&#34;using-with-blog-comments:91190a79664036955176de2fc388a61f&#34;&gt;Using with Blog Comments&lt;/h1&gt;

&lt;p&gt;While cool, this example isn&amp;rsquo;t that practical. In reality you&amp;rsquo;ll rarely have a scenario where you need to write HTML inside of a web browser, otherwise using a static site generator is probably what you&amp;rsquo;ll be using.&lt;/p&gt;

&lt;p&gt;One place where you would want to generate the HTML on the fly is for blog comments. If your blog is developer-focused it makes sense to allow the reader to write comments in markdown, and have a live preview of what it will look like. So let&amp;rsquo;s refactor &lt;code&gt;&amp;lt;x-markdown&amp;gt;&lt;/code&gt; to be our live preview.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;can.Component.extend({
  tag: &#39;x-markdown&#39;,
  template: &#39;&amp;lt;div&amp;gt;{{{html}}}&amp;lt;/div&amp;gt;&#39;,
  scope: {
    html: can.compute(function() {
      var markdown = this.attr(&#39;markdown&#39;);
      var converter = new Showdown.converter();
      var html = converter.makeHtml(markdown);
      return html;
    }),
    markdown: &#39;&#39;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This new version of &lt;code&gt;&amp;lt;x-markdown&amp;gt;&lt;/code&gt; is much more succinct because we&amp;rsquo;ve eliminated the &lt;code&gt;&amp;lt;content/&amp;gt;&lt;/code&gt; portion by getting the raw markdown from a textarea. can.Component allows you to pass data (included complex objects) through an element&amp;rsquo;s attribute tags. We&amp;rsquo;ll use it like such: &lt;code&gt;&amp;lt;x-markdown markdown=&amp;quot;value&amp;quot;&amp;gt;&amp;lt;/x-markdown&amp;gt;&lt;/code&gt; so that the &lt;code&gt;html&lt;/code&gt; compute will be live-bound to the &lt;code&gt;value&lt;/code&gt; object that we pass in.&lt;/p&gt;

&lt;p&gt;Next we need to create a live-bound textarea we&amp;rsquo;ll call &lt;code&gt;&amp;lt;x-textarea&amp;gt;&lt;/code&gt;. The idea that both x-markdown and x-textarea will be live-bound to the same compute object, and any time you type into the textarea the markdown will automatically be rerendered in the preview window. Demo time:&lt;/p&gt;

&lt;h2 id=&#34;demo-1:91190a79664036955176de2fc388a61f&#34;&gt;Demo&lt;/h2&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;300&#34; src=&#34;http://jsfiddle.net/TBFp6/6/embedded/&#34; allowfullscreen=&#34;allowfullscreen&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Try out the fiddle (Click on the &lt;strong&gt;Result&lt;/strong&gt; link) and see for yourself how the preview updates as you type. The secret sauce here is that we are using &lt;code&gt;can-value&lt;/code&gt; to bind the textarea&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; to our scope property also called &lt;code&gt;value&lt;/code&gt;. can-value works on the element&amp;rsquo;s &lt;code&gt;change&lt;/code&gt; event, which for most types of forms is fine, but in our case we need the preview to update as you type, so we&amp;rsquo;ve added a &lt;code&gt;keyup&lt;/code&gt; event that simply triggers the textarea&amp;rsquo;s change event as the user types. Simple!&lt;/p&gt;

&lt;h1 id=&#34;when-not-to-web-component:91190a79664036955176de2fc388a61f&#34;&gt;When not to Web Component&lt;/h1&gt;

&lt;p&gt;Awesome, we&amp;rsquo;ve built a live-bound markdown enabled comment system. In less than 30 lines of code. However you might notice that the &lt;code&gt;&amp;lt;x-textarea&amp;gt;&lt;/code&gt; isn&amp;rsquo;t really doing much at all. It simply turns a normal textarea into a live-bound one.&lt;/p&gt;

&lt;p&gt;However in reality textareas &lt;em&gt;really are&lt;/em&gt; live-bound, they use the normal DOM events to update their values. So all we are using the &lt;code&gt;&amp;lt;x-textarea&amp;gt;&lt;/code&gt; for in practice is to turn the DOM events into can events. Luckily &lt;a href=&#34;http://canjs.com/docs/can.compute.html&#34;&gt;can.compute&lt;/a&gt; already has a way of doing this, so we don&amp;rsquo;t need the &lt;code&gt;x-textarea&lt;/code&gt; at all.&lt;/p&gt;

&lt;p&gt;can.compute can take a set of arguments that includes an element, the property to bind to, and an event to bind to. We&amp;rsquo;ll use it like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var markdown = can.compute(textarea, &#39;value&#39;, &#39;keyup&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to move our textarea outside of the script tag (since we&amp;rsquo;re getting rid of the component) but still have a live-bound value between the textarea and our &lt;code&gt;x-markdown&lt;/code&gt; preview. See the demo below.&lt;/p&gt;

&lt;h2 id=&#34;demo-2:91190a79664036955176de2fc388a61f&#34;&gt;Demo&lt;/h2&gt;

&lt;iframe width=&#34;100%&#34; height=&#34;300&#34; src=&#34;http://jsfiddle.net/TBFp6/5/embedded/&#34; allowfullscreen=&#34;allowfullscreen&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;

&lt;p&gt;Hopefully I&amp;rsquo;ve demonstrated the process of coming up with an idea for a component (essentially an encapsulated piece of HTML with JavaScript interactivity) and refining it until you are left with only the bits of code that you need. We&amp;rsquo;ve created a Markdown-enabled blog commenting system is only 18 lines of code. Let it be inspiration for your next component. Can you do better, how about an MDN reference widget?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>