<html>
<head>
	<title>On JavaScript and modules</title>
	<link rel="stylesheet" href="/css/reset.css" />
	<link rel="stylesheet" href="/css/post.css" />
	<link rel="alternate" href="/atom.xml" type="application/atom+xml"  title="Matthew Phillips ATOM Feed" />
	<!--[if lt IE 9]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>
<body>
<article>
	<header>
		<h1>On JavaScript and modules</h1>
		<time datetime="2013-03-17">March 17th, 2013</time>
  </header>
  <p>Writing modular JavaScript in the browser is harder than ever these days, despite having more tools than ever meant to remedy the problem. Whether you choose <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a> or <a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a>, <a href="http://component.io/">Component</a> or <a href="http://browserify.org/">Browserify</a> you are choosing a solution that lacks forward compatibility. EMCAScript 6 will fix the issue, finally, but until then we must wade through bad choices.</p>
  <h2>The script tag</h2>
  <p>For my money, the script tag is still the best way to write module code in the browser. Typical solutions these days either have you writing a JSON file that lists your dependencies or perhaps tries to infer them from clever naming conventions. But it seems obvious to me that there is no better way to lay out your javascript dependencies than through a straight list of script tags.</p>
  <p>There are 2 main problems with this approach:</p>
  <ul>
    <li>Polluting global. We get around this by wrapping out code in an anonymous function but this is just an ugly hack and doesn't fix the fact that if we want to export something back out the only option is to attach it to the window.</li>
    <li>Order matters. The browser blindly executes scripts in the order they appear in html, so that means you have to be conscious of what order you add them.</li>
  </ul>
  <p>So what does this mean? The script tag is out. A single global script tag is OK, but it's not really a good way to write modular JavaScript.</p>
  <h2>Standards!</h2>
  <p>This is the part where a bunch of developers get together and decide on how JavaScript modules should work, agree on a basic API... and then come up with 2 competing APIs. So today we have AMD and CommonJS.  This is really not so bad, they are close enough to each other that a lot of libraries wind up supporting both of them. But this still sucks badly as I can't blindly add a library to my app and know that it will work.</p>
  <p>Worse is that these approaches suffer from the "end user has to know too much" problem. A developer should only need know the syntax and the library that needs to be added. Go checkout out <a href="http://requirejs.org/docs/start.html">RequireJS</a> for a moment, it asks you to layout your app in a very particular way, it has an optimizer even. This is too much to ask for something that is not forward compatible.</p>
  <h2>Package managers</h2>
  <p>Package managers are yet another solution to the sad state of modular in browsers. They solve the "which modular syntax do I use" problem by picking one for you. They also provide a convenient way to find other libraries that support their infrastructure. So that takes care of the "I don't know if my library supports this" problem. You know because it will be in the registry.</p>
  <p>This still feels dirty, however. It still isn't forward compatible, it still requires you to work a certain way. In particular these all use compiling to generate a build for your app. This is undesirable as it slows down the event loop for testing, and it requires that you work a certain way (namely that you use an environment that has access to a command line; and frankly most of these assume you are using Unix).</p>
  <h2>ES6 is the way forward, let's get started now</h2>
  <p>Since we already know what modularity will look like in the future, why don't we go ahead and start down that path?</p>
  <p>Shimming ES6 modules is very difficult, due to new syntax. Export and Import keywords are not compatible with ES5 engines. This means you have to compile your ES6 code to something useable in ES5 browsers. Square wrote a <a href="http://corner.squareup.com/2013/02/es6-module-transpiler.html">library for Node</a> that does exactly this, by turning ES6 modules into AMD/CJS modules that can be used today. This is great! This solves most of the problems we have with modules today; it's forwards compatible, it doesn't require much knowledge of the underlying workings to use... the only problem is that it does require compiling.</p>
  <p>So let's take this a step forward. Let's write modules exactly like we'll do when ES6 is pervasive, or at least very close to how we'll write them.</p>
  <p>That's why I've started the <a href="https://github.com/matthewp/es6modulesnow">es6modulesnow</a> (terrible name, I know) project. My goal is to allow you to include 1 script and then just write modules the way you'll be writing them a year or 2 from now. And when that time comes, you can simply remove the library from your page and everything will work the same.</p>
  <p>It's not perfect though, it's definitely very alpha-ey. You can't, for example, do:</p>
  <pre>import 'https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js' as $;</pre>
  <p>At least not yet, I'm working on that. But I need help, as this is a big problem to solve. Fork the code on GitHub, create issues. Let's start writing ES6 modules today, so we can leave behind the frustrations we currently suffer through.</p> 
	<footer>
		<p>Matthew Phillips</p>
	</footer>
</article>
</body>
</html>
